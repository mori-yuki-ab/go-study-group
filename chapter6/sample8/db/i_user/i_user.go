// Code generated by core tool ; DO NOT EDIT.

package i_user

import (
	"bytes"
	"database/sql"
	"encoding/binary"
	"strconv"
	"time"

	"apb-gitlab.abot.sh/apbgo/golib/pkg/db/bean"
	"apb-gitlab.abot.sh/apbgo/golib/pkg/exception"
	enum "github.com/apbgo/go-study-group/chapter6/sample8/db/enum"
	"gopkg.in/guregu/null.v3"
)

const (
	TableName       = "i_user"
	ConnectionGroup = "default"
)

const (
	ColumnUserId            = "user_id"
	ColumnOsType            = "os_type"
	ColumnName              = "name"
	ColumnGamestartDatetime = "gamestart_datetime"
	ColumnLatestVersion     = "latest_version"
	ColumnCreatedAt         = "created_at"
	ColumnUpdatedAt         = "updated_at"
	ColumnDeletedAt         = "deleted_at"

	ColumnManageMentComment    = "management_comment"
	ColumnLatestUpdateDatetime = "latest_update_datetime"
)

var (
	PrimaryKeys = []string{
		ColumnUserId,
	}
	Columns = []string{
		ColumnUserId,
		ColumnOsType,
		ColumnName,
		ColumnGamestartDatetime,
		ColumnLatestVersion,
		ColumnCreatedAt,
		ColumnUpdatedAt,
		ColumnDeletedAt,
	}
)

type IUser struct {
	// UserId ユーザーID
	UserId int64 `xorm:"user_id" db:"user_id" json:"user_id"`
	// OsType OSタイプ
	OsType enum.OsType `xorm:"os_type" db:"os_type" json:"os_type"`
	// Name ユーザー名
	Name string `xorm:"name" db:"name" json:"name"`
	// GamestartDatetime ゲーム開始日時
	GamestartDatetime null.Time `xorm:"gamestart_datetime" db:"gamestart_datetime" json:"gamestart_datetime"`
	// LatestVersion 最終バージョン
	LatestVersion int64 `xorm:"latest_version" db:"latest_version" json:"latest_version"`
	// CreatedAt 作成日時
	CreatedAt time.Time `xorm:"created_at" db:"created_at" json:"created_at"`
	// UpdatedAt 更新日時
	UpdatedAt time.Time `xorm:"updated_at" db:"updated_at" json:"updated_at"`
	// DeletedAt 削除日時
	DeletedAt null.Time `xorm:"deleted_at" db:"deleted_at" json:"deleted_at"`

	original   Original            `xorm:"-" db:"-"`
	cacheState bean.TypeCacheState `xorm:"-" db:"-"`
	cacheOrder int                 `xorm:"-" db:"-"`
}

type Original struct {
	UserId            int64
	OsType            enum.OsType
	Name              string
	GamestartDatetime null.Time
	LatestVersion     int64
	CreatedAt         time.Time
	UpdatedAt         time.Time
	DeletedAt         null.Time
}

func (m *IUser) Table() string {
	return TableName
}

func (m *IUser) ConnectionGroup() string {
	return ConnectionGroup
}

func (m *IUser) PrimaryKeys() []string {
	return PrimaryKeys
}

func (m *IUser) Columns() []string {
	return Columns
}

func (m *IUser) ShardKey() string {
	return ""
}

func (m *IUser) ShardValue() interface{} {
	return nil
}

func (m *IUser) UpdatedColumns() []string {
	cols := make([]string, 0, 8)

	// 主キーは変更不可

	if m.OsType != m.original.OsType {
		cols = append(cols, ColumnOsType)
	}

	if m.Name != m.original.Name {
		cols = append(cols, ColumnName)
	}

	if m.GamestartDatetime != m.original.GamestartDatetime {
		cols = append(cols, ColumnGamestartDatetime)
	}

	if m.LatestVersion != m.original.LatestVersion {
		cols = append(cols, ColumnLatestVersion)
	}

	if m.CreatedAt != m.original.CreatedAt {
		cols = append(cols, ColumnCreatedAt)
	}

	if m.UpdatedAt != m.original.UpdatedAt {
		cols = append(cols, ColumnUpdatedAt)
	}

	if m.DeletedAt != m.original.DeletedAt {
		cols = append(cols, ColumnDeletedAt)
	}

	return cols
}

func (m *IUser) IsCreated() bool {
	return m.CreatedAt.IsZero()
}

func (m *IUser) AsCreated(t time.Time) {
	m.CreatedAt = t
}

func (m *IUser) IsUpdated() bool {
	return !m.UpdatedAt.IsZero()
}

func (m *IUser) AsUpdated(t time.Time) {
	m.UpdatedAt = t
}

func (m *IUser) IsDeleted() bool {
	return !m.DeletedAt.IsZero()
}

func (m *IUser) AsDeleted(t time.Time) {
	m.DeletedAt = null.NewTime(t, true)
}

func (m *IUser) DeleteColumn() string {
	return ColumnDeletedAt
}

func (m *IUser) GetValue(col string) interface{} {
	switch col {
	case ColumnUserId:
		return m.UserId
	case ColumnOsType:
		return int64(m.OsType)
	case ColumnName:
		return m.Name
	case ColumnGamestartDatetime:
		return m.GamestartDatetime
	case ColumnLatestVersion:
		return m.LatestVersion
	case ColumnCreatedAt:
		return m.CreatedAt
	case ColumnUpdatedAt:
		return m.UpdatedAt
	case ColumnDeletedAt:
		return m.DeletedAt
	}
	return nil
}

func (m *IUser) ToStringMap() map[string]string {
	var (
		userId            string
		osType            string
		name              string
		gamestartDatetime string
		latestVersion     string
		createdAt         string
		updatedAt         string
		deletedAt         string
	)

	userId = strconv.FormatInt(m.UserId, 10)
	osType = strconv.FormatInt(int64(m.OsType), 10)
	name = m.Name
	if !m.GamestartDatetime.IsZero() {
		gamestartDatetime = m.GamestartDatetime.Time.Format(time.RFC3339)
	}
	latestVersion = strconv.FormatInt(m.LatestVersion, 10)
	createdAt = m.CreatedAt.Format(time.RFC3339)
	updatedAt = m.UpdatedAt.Format(time.RFC3339)
	if !m.DeletedAt.IsZero() {
		deletedAt = m.DeletedAt.Time.Format(time.RFC3339)
	}
	return map[string]string{
		"user_id":            userId,
		"os_type":            osType,
		"name":               name,
		"gamestart_datetime": gamestartDatetime,
		"latest_version":     latestVersion,
		"created_at":         createdAt,
		"updated_at":         updatedAt,
		"deleted_at":         deletedAt,
	}
}

func (m *IUser) WriteValue(col string, buf *bytes.Buffer) (bool, error) {
	var (
		b []byte
		n bool
	)
	switch col {
	case ColumnUserId:
		b = make([]byte, 8)
		binary.LittleEndian.PutUint64(b, uint64(m.UserId))
	case ColumnOsType:
		b = make([]byte, 8)
		binary.LittleEndian.PutUint64(b, uint64(m.OsType))
	case ColumnName:
		b = []byte(m.Name)
	case ColumnGamestartDatetime:
		if !m.GamestartDatetime.IsZero() {
			b = make([]byte, 8)
			binary.LittleEndian.PutUint64(b, uint64(m.GamestartDatetime.Time.UnixNano()))
		} else {
			n = true
		}
	case ColumnLatestVersion:
		b = make([]byte, 8)
		binary.LittleEndian.PutUint64(b, uint64(m.LatestVersion))
	case ColumnCreatedAt:
		b = make([]byte, 8)
		binary.LittleEndian.PutUint64(b, uint64(m.CreatedAt.UnixNano()))
	case ColumnUpdatedAt:
		b = make([]byte, 8)
		binary.LittleEndian.PutUint64(b, uint64(m.UpdatedAt.UnixNano()))
	case ColumnDeletedAt:
		if !m.DeletedAt.IsZero() {
			b = make([]byte, 8)
			binary.LittleEndian.PutUint64(b, uint64(m.DeletedAt.Time.UnixNano()))
		} else {
			n = true
		}
	}
	_, err := buf.Write(b)
	if err != nil {
		return false, exception.New(exception.UnExpected, "can not write to buffer").Wrap(err)
	}
	return n, nil
}

func (m *IUser) Bind(rows *sql.Rows) error {
	if m == nil {
		return exception.New(exception.UnExpected, "model is nil")
	}

	err := rows.Scan(
		&m.UserId,
		&m.OsType,
		&m.Name,
		&m.GamestartDatetime,
		&m.LatestVersion,
		&m.CreatedAt,
		&m.UpdatedAt,
		&m.DeletedAt,
	)
	if err != nil {
		return err
	}

	m.UpdateOriginal()
	return nil
}

func (m *IUser) UpdateOriginal() {
	m.original.UserId = m.UserId
	m.original.OsType = m.OsType
	m.original.Name = m.Name
	m.original.GamestartDatetime = m.GamestartDatetime
	m.original.LatestVersion = m.LatestVersion
	m.original.CreatedAt = m.CreatedAt
	m.original.UpdatedAt = m.UpdatedAt
	m.original.DeletedAt = m.DeletedAt
}

func (m *IUser) ToBeans() bean.IFBeans {
	return &IUsers{m}
}

func (m IUser) Equal(target IUser) bool {

	if m.UserId != target.UserId {
		return false
	}

	if m.OsType != target.OsType {
		return false
	}

	if m.Name != target.Name {
		return false
	}

	if m.GamestartDatetime != target.GamestartDatetime {
		return false
	}

	if m.LatestVersion != target.LatestVersion {
		return false
	}

	if m.CreatedAt != target.CreatedAt {
		return false
	}

	if m.UpdatedAt != target.UpdatedAt {
		return false
	}

	if m.DeletedAt != target.DeletedAt {
		return false
	}

	return true
}

func (m *IUser) Update(src bean.IFBean) error {
	if m == nil {
		return exception.New(exception.UnExpected, "model is nil")
	}

	if src == nil {
		return exception.New(exception.UnExpected, "src is nil")
	}

	srcModel, ok := src.(*IUser)
	if !ok {
		return exception.New(exception.UnExpected, "src is not *IUser.")
	}

	m.UserId = srcModel.UserId
	m.OsType = srcModel.OsType
	m.Name = srcModel.Name
	m.GamestartDatetime = srcModel.GamestartDatetime
	m.LatestVersion = srcModel.LatestVersion
	m.CreatedAt = srcModel.CreatedAt
	m.UpdatedAt = srcModel.UpdatedAt
	m.DeletedAt = srcModel.DeletedAt

	return nil
}

func (m *IUser) Validate() error {
	// floatやdouble, decimal, 細かいテキスト型などは未対応なので、必要な場合はtmplにValidationを追加すること
	if m.UserId < -9223372036854775808 || 9223372036854775807 < m.UserId {
		return exception.New(exception.UnExpected, "validation error. invalid column value.").WithValues(map[string]interface{}{"column": "UserId", "value": m.UserId})
	}
	if !m.OsType.Within() {
		return exception.New(exception.UnExpected, "validation error. invalid column value.").WithValues(map[string]interface{}{"column": "OsType", "value": m.OsType})
	}
	if 16 < len(m.Name) {
		return exception.New(exception.UnExpected, "validation error. invalid column value.").WithValues(map[string]interface{}{"column": "Name", "value": m.Name})
	}
	if m.LatestVersion < -9223372036854775808 || 9223372036854775807 < m.LatestVersion {
		return exception.New(exception.UnExpected, "validation error. invalid column value.").WithValues(map[string]interface{}{"column": "LatestVersion", "value": m.LatestVersion})
	}
	return nil
}

func (m *IUser) UniqueKey() string {
	return strconv.FormatInt(m.UserId, 10)
}

func (m *IUser) UniqueKeySeparator() string {
	return ":"
}

func (m *IUser) CacheState() bean.TypeCacheState {
	return m.cacheState
}

func (m *IUser) SetCacheState(state bean.TypeCacheState) {
	m.cacheState = state
}

func (m *IUser) CacheOrder() int {
	return m.cacheOrder
}

func (m *IUser) SetCacheOrder(o int) {
	m.cacheOrder = o
}

func (m *IUser) ToCacheableBeans() bean.IFCacheableBeans {
	return &IUsers{m}
}

type IUsers []*IUser

func (ms IUsers) Table() string {
	return TableName
}

func (ms IUsers) ShardKey() string {
	return ""
}

func (ms IUsers) ConnectionGroup() string {
	return ConnectionGroup
}

func (ms *IUsers) PrimaryKeys() []string {
	return PrimaryKeys
}

func (ms IUsers) Columns() []string {
	return Columns
}

func (ms *IUsers) Reset() {
	v := *ms
	*ms = v[:0]
}

func (ms *IUsers) Bind(rows *sql.Rows) error {
	m := &IUser{}
	err := m.Bind(rows)
	if err != nil {
		return err
	}

	*ms = append(*ms, m)
	return nil
}

func (ms *IUsers) Add(bean interface{}) error {
	m, ok := bean.(*IUser)
	if !ok {
		return exception.New(exception.UnExpected, "引数が型と一致しません. 型=iUser")
	}

	*ms = append(*ms, m)
	return nil
}

func (ms IUsers) ForeachBean(f func(bean bean.IFBean) error) error {
	for i := range ms {
		if err := f(ms[i]); err != nil {
			return err
		}
	}
	return nil
}

func (ms IUsers) ForeachCacheableBean(f func(bean bean.IFCacheableBean) error) error {
	for i := range ms {
		if err := f(ms[i]); err != nil {
			return err
		}
	}
	return nil
}

func (ms IUsers) Len() int {
	return len(ms)
}

func (ms IUsers) DeleteColumn() string {
	return ColumnDeletedAt
}
