// Code generated by MockGen. DO NOT EDIT.
// Source: kadai.go

// Package chapter6 is a generated GoMock package.
package chapter6

import (
	context "context"
	sql "database/sql"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockIFUserItemService is a mock of IFUserItemService interface
type MockIFUserItemService struct {
	ctrl     *gomock.Controller
	recorder *MockIFUserItemServiceMockRecorder
}

// MockIFUserItemServiceMockRecorder is the mock recorder for MockIFUserItemService
type MockIFUserItemServiceMockRecorder struct {
	mock *MockIFUserItemService
}

// NewMockIFUserItemService creates a new mock instance
func NewMockIFUserItemService(ctrl *gomock.Controller) *MockIFUserItemService {
	mock := &MockIFUserItemService{ctrl: ctrl}
	mock.recorder = &MockIFUserItemServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIFUserItemService) EXPECT() *MockIFUserItemServiceMockRecorder {
	return m.recorder
}

// Provide mocks base method
func (m *MockIFUserItemService) Provide(ctx context.Context, userID int64, rewards ...Reward) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, userID}
	for _, a := range rewards {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Provide", varargs...)
}

// Provide indicates an expected call of Provide
func (mr *MockIFUserItemServiceMockRecorder) Provide(ctx, userID interface{}, rewards ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, userID}, rewards...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Provide", reflect.TypeOf((*MockIFUserItemService)(nil).Provide), varargs...)
}

// MockIFUserItemRepository is a mock of IFUserItemRepository interface
type MockIFUserItemRepository struct {
	ctrl     *gomock.Controller
	recorder *MockIFUserItemRepositoryMockRecorder
}

// MockIFUserItemRepositoryMockRecorder is the mock recorder for MockIFUserItemRepository
type MockIFUserItemRepositoryMockRecorder struct {
	mock *MockIFUserItemRepository
}

// NewMockIFUserItemRepository creates a new mock instance
func NewMockIFUserItemRepository(ctrl *gomock.Controller) *MockIFUserItemRepository {
	mock := &MockIFUserItemRepository{ctrl: ctrl}
	mock.recorder = &MockIFUserItemRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIFUserItemRepository) EXPECT() *MockIFUserItemRepositoryMockRecorder {
	return m.recorder
}

// FindByUserIdAndItemIDs mocks base method
func (m *MockIFUserItemRepository) FindByUserIdAndItemIDs(ctx context.Context, tx *sql.Tx, userID int64, itemIDs []int64) ([]*IUserItem, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByUserIdAndItemIDs", ctx, tx, userID, itemIDs)
	ret0, _ := ret[0].([]*IUserItem)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByUserIdAndItemIDs indicates an expected call of FindByUserIdAndItemIDs
func (mr *MockIFUserItemRepositoryMockRecorder) FindByUserIdAndItemIDs(ctx, tx, userID, itemIDs interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByUserIdAndItemIDs", reflect.TypeOf((*MockIFUserItemRepository)(nil).FindByUserIdAndItemIDs), ctx, tx, userID, itemIDs)
}

// Insert mocks base method
func (m *MockIFUserItemRepository) Insert(ctx context.Context, tx *sql.Tx, iUserItem *IUserItem) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", ctx, tx, iUserItem)
	ret0, _ := ret[0].(error)
	return ret0
}

// Insert indicates an expected call of Insert
func (mr *MockIFUserItemRepositoryMockRecorder) Insert(ctx, tx, iUserItem interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockIFUserItemRepository)(nil).Insert), ctx, tx, iUserItem)
}

// Update mocks base method
func (m *MockIFUserItemRepository) Update(ctx context.Context, tx *sql.Tx, iUserItem *IUserItem) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, tx, iUserItem)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update
func (mr *MockIFUserItemRepositoryMockRecorder) Update(ctx, tx, iUserItem interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockIFUserItemRepository)(nil).Update), ctx, tx, iUserItem)
}
